"""
Модуль с двумя реализациями факториала и небольшим самотестом.

- fact_recursive(n): рекурсивная версия
- fact_iterative(n): итеративная версия (через цикл)

Документация следует PEP-257: краткое резюме сверху, затем подробности.
Подсказки по типам добавлены для читаемости и проверки mypy/IDE.
"""

from __future__ import annotations
from typing import Final


def fact_recursive(n: int) -> int:
    """Вычислите n! рекурсивно.

    Предусловия:
        - n должен быть неотрицательным целым числом.
    Возвращает:
        - факториал n как целое число.

    Примечания:
        - Рекурсия углубляется на n вызовов. Для очень больших n может
          упереться в лимит рекурсии Python (обычно ~1000).
    """
    # Проверяем корректность входа — это полезно для обучения и отладки.
    if n < 0:
        raise ValueError("n должно быть неотрицательным.")
    # База рекурсии: 0! и 1! равны 1.
    if n < 2:
        return 1
    # Рекурсивное определение: n! = n * (n-1)!
    return n * fact_recursive(n - 1)


def fact_iterative(n: int) -> int:
    """Вычислите n! итеративно (через цикл).

    Предусловия:
        - n должен быть неотрицательным целым числом.
    Возвращает:
        - факториал n как целое число.

    Идея:
        - Идём от 2 до n и перемножаем значения в аккумуляторе.
    """
    if n < 0:
        raise ValueError("n должно быть неотрицательным.")
    result: int = 1  # аккумулятор произведения
    # Для n=0 или n=1 цикл просто не выполнится, и результат останется 1.
    for k in range(2, n + 1):
        result *= k
    return result


if __name__ == "__main__":
    # ----- Небольшой самотест -----
    # Идея: проверим несколько значений n и убедимся,
    # что обе реализации дают одинаковый результат.

    TEST_VALUES: Final[list[int]] = [0, 1, 2, 3, 5, 10, 20]
    print("Самотест двух реализаций факториала:")
    for n in TEST_VALUES:
        r_rec = fact_recursive(n)
        r_it = fact_iterative(n)
        # Печатаем результат и отмечаем, совпадают ли реализации.
        status = "OK" if r_rec == r_it else "MISMATCH"
        print(f"n={n:>2}: rec={r_rec}, iter={r_it} -> {status}")

    # Небольшая демонстрация ошибки на отрицательных числах:
    try:
        fact_iterative(-1)
    except ValueError as exc:
        print("Ожидаемая ошибка для n<0 (iterative):", exc)
